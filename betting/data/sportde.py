# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_sportde.ipynb (unless otherwise specified).

__all__ = ['BASE_URL', 'season_links_from_page', 'get_matchday_links', 'get_matchday_dates', 'get_match_infos',
           'get_standings', 'scrape_season', 'set_dtypes', 'save_season']

# Cell
from ..scraping import *
import re
from datetime import datetime
import pandas as pd

# Cell
BASE_URL = 'https://www.sport.de'

# Cell
def season_links_from_page(bs):
    select_element = bs.find_all('select', {'class': 'navigation season-navigation'})[0]
    seasons_urls = {}

    for option in select_element.find_all('option'):
        match = re.match(r'''/fussball/[^/]+/.+/(\d\d\d\d-\d\d\d\d)/ergebnisse-und-tabelle/''', option['value'])
        if match is None:
            print(option['value'])
            continue
        url = match.group(0)
        season = match.group(1)
        if int(season[:4])<1950: continue
        season = season[2] + season[3] + season[7] + season[8]
        seasons_urls[season] = BASE_URL + url

    return seasons_urls

# Cell
def get_matchday_links(bs, expected_length=34):
    matchday_links = []
    for li in bs.find_all('li'):
        try:
            matchday_links.append(BASE_URL+li['data'])
        except:
            pass

    if expected_length is not None:
        assert len(matchday_links)==expected_length, f'Expected: {expected_length}. Actual: {len(matchday_links)}'
    return matchday_links

# Cell
def get_matchday_dates(matchday_bs):
    divs = matchday_bs.find_all('div', {'class': 'match-date'})
    dates = [div.text.split(' ')[0] for div in divs]
    dates = list(set(map(lambda d: datetime.strptime(d, '%d.%m.%Y'), dates)))
    return dates

# Cell
def get_match_infos(matchday_bs):
    """
    Returns [[home_team, away_team, home_goals, away_goals], ...]
    """
    divs = [div for div in matchday_bs.find_all('div') if 'position' in div.attrs.keys()]
    matches = []
    for div in divs:
        home_team = div.find('div', {'class', 'team-shortname-home'}).text
        away_team = div.find('div', {'class', 'team-shortname-away'}).text

        home_div = div.find('div', {'class', 'match-result match-result-home'})
        home_goals = int(home_div.find('div', {'class': 'match-result match-result-0'}).text)

        away_div = div.find('div', {'class', 'match-result match-result-away'})
        away_goals = int(away_div.find('div', {'class': 'match-result match-result-0'}).text)

        match = [home_team, away_team, home_goals, away_goals]
        matches.append(match)

    return matches

# Cell
def get_standings(matchday_bs):
    """
    Returns [[rank, team, games_played, wins, draw, lost, total_goals_scored, total_goals_received, points], ...]
    """
    standing_divs = matchday_bs.find_all('tr', {'class': 'standing'})
    standings = []

    for div in standing_divs:
        rank = div.find('td', {'class': 'standing-rank'}).text
        team = div.find('td', {'class': 'team-shortname'}).text
        games_played = div.find('td', {'class': 'standing-games_played'}).text

        wins = div.find('td', {'class': 'standing-win'}).text
        draw = div.find('td', {'class': 'standing-draw'}).text
        lost = div.find('td', {'class': 'standing-lost'}).text

        total_goals = div.find('td', {'class': 'standing-goaldiff'}).text
        total_goals_scored, total_goals_received = total_goals.split(':')

        points = div.find('td', {'class': 'standing-points'}).text

        standing = [rank, team, games_played, wins, draw, lost, total_goals_scored, total_goals_received, points]
        standings.append(standing)

    return standings

# Cell
def scrape_season(season, season_link, expected_matchdays=None, do_cache=False):
    season_bs = get_html(season_link)
    matchday_links = get_matchday_links(season_bs, expected_length=expected_matchdays)

    standings = []
    matchdays = []
    games = []

    for matchday_link in matchday_links:
        matchday = re.search('/md([^/]+)/', matchday_link).group(1)
        if do_cache: matchday_bs = cache(matchday_link, f'scrape_{season}_{matchday}_premiera')
        else: matchday_bs = get_html(matchday_link)

        dates = get_matchday_dates(matchday_bs)
        matchdays.append([season, matchday, min(dates), max(dates)])

        day_standings = get_standings(matchday_bs)
        for day_standing in day_standings:
            row = [season, matchday, *day_standing]
            standings.append(row)

        day_games = get_match_infos(matchday_bs)
        for day_game in day_games:
            row = [season, matchday, *day_game]
            games.append(row)

    return standings, matchdays, games

# Cell
def set_dtypes(df, dtypes):
    n_cols = df.shape[1]
    for col,dtype in enumerate(dtypes):
        df.iloc[:,col] = df.iloc[:,col].astype(dtype)
    return df

def save_season(standings, matchdays, games, league, save_path):
    matchday_df = pd.DataFrame(matchdays, columns=['season', 'matchday', 'start_date', 'end_date'])
    matchday_df.matchday = matchday_df.matchday.astype(int)
    matchday_df['league'] = league

    season = matchday_df['season'].unique()
    assert len(season)==1, f'Expected DataFrame of only one season, found: {season}'
    season = season[0]

    matchday_path = save_path/f'{season}_matchdays.feather'
    matchday_df.to_feather(matchday_path)

    standings_df = pd.DataFrame(standings, columns=['season', 'matchday', 'rank', 'team', 'games_played', 'wins', 'draw', 'lost', 'total_goals_scored', 'total_goals_received', 'points'])
    standings_df = set_dtypes(standings_df, [str, int, int, str, int, int, int, int, int, int, int])
    standings_df['league'] = league
    standings_path = save_path/f'{season}_standings.feather'
    standings_df.to_feather(standings_path)

    games_df = pd.DataFrame(games, columns=['season', 'matchday', 'home_team', 'away_team', 'home_goals', 'away_goals'])
    games_df = set_dtypes(games_df, [str, int, str, str, int, int])
    games_df['league'] = league
    games_path = save_path/f'{season}_games.feather'
    games_df.to_feather(games_path)

    return matchday_path, standings_path, games_path