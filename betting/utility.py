# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_utility.ipynb (unless otherwise specified).

__all__ = ['run_in_parallel', 'overlapping_cols', 'merge_with_prefix', 'similar_score', 'similar_n',
           'create_translation', 'reverse_dict']

# Cell
import multiprocessing as mp

# Cell
def run_in_parallel(func, iterable, n_workers=6):
    pool = mp.Pool(processes=n_workers)
    return pool.map(func, iterable)

# Cell
import pandas as pd

# Cell
def overlapping_cols(df1, df2):
    return [col1 for col1 in df1.columns if col1 in df2.columns]


def merge_with_prefix(original, additional, prefix, left_on=None, right_on=None, drop_additional=False):
    assert not ((left_on is not None) ^ (right_on is not None)), "Leave both left_on and right_on as None to merge over all columns with the same name or specify both."

    if right_on is None:
        left_on = overlapping_cols(original, additional)
        right_on = left_on

    col_renamer = {col: prefix+col for col in additional.columns if not col in right_on}
    to_merge = additional.rename(col_renamer, axis='columns')

    merged = pd.merge(original, to_merge, left_on=left_on, right_on=right_on)

    if drop_additional:
        to_drop = [col for col in right_on if not col in left_on]
        merged.drop(columns=to_drop, inplace=True)

    return merged

# Cell
import numpy as np
from difflib import SequenceMatcher

# Cell
def similar_score(a, b):
    return SequenceMatcher(None, a, b).ratio()

def similar_n(actual, targets, n=5):
    scores = np.array([similar_score(actual, target) for target in targets])
    ids = scores.argsort()[-n:]
    return [targets[id] for id in reversed(ids)]

# Cell
def create_translation(actuals, targets):
    return {actual: similar_n(actual, targets, n=1)[0] for actual in actuals}

# Cell
def reverse_dict(d):
    return {value: key for key,value in d.items()}